<!DOCTYPE html>
<html>
<head>
    <title>NexusLIMS Download</title>
</head>
<body>
<script>
/**
 * This page runs inside an iframe and is controlled by our service worker.
 * It receives download configuration from the parent and triggers the download.
 */

async function init() {
    console.log('[DownloadFrame] Initializing...');
    console.log('[DownloadFrame] SW controller:', !!navigator.serviceWorker.controller);

    // Wait for service worker to control this page
    if (!navigator.serviceWorker.controller) {
        console.log('[DownloadFrame] Waiting for SW to control this page...');
        await new Promise(resolve => {
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('[DownloadFrame] SW now controlling this page');
                resolve();
            });
            // Also check periodically in case we missed the event
            const check = setInterval(() => {
                if (navigator.serviceWorker.controller) {
                    clearInterval(check);
                    resolve();
                }
            }, 100);
            // Timeout after 10 seconds for Safari
            setTimeout(() => {
                clearInterval(check);
                console.warn('[DownloadFrame] Timeout waiting for SW control');
                resolve();
            }, 10000);
        });
    }

    console.log('[DownloadFrame] Ready, SW controller:', !!navigator.serviceWorker.controller);

    // Signal to parent that we're loaded and SW-controlled
    if (window.parent && window.parent !== window) {
        window.parent.postMessage({
            type: 'FRAME_READY',
            controlled: !!navigator.serviceWorker.controller
        }, '*');
    }
}

// Listen for download trigger from parent
window.addEventListener('message', async (event) => {
    // Only accept messages from parent
    if (event.source !== window.parent) return;

    const { type, downloadUrl } = event.data;

    if (type === 'TRIGGER_DOWNLOAD') {
        console.log('[DownloadFrame] Triggering download:', downloadUrl);
        console.log('[DownloadFrame] SW controller at trigger time:', !!navigator.serviceWorker.controller);

        try {
            // Use fetch instead of navigation so we can catch errors
            console.log('[DownloadFrame] Fetching...');
            const response = await fetch(downloadUrl);
            console.log('[DownloadFrame] Response status:', response.status, response.statusText);
            console.log('[DownloadFrame] Response headers:', [...response.headers.entries()]);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            // Get the filename from Content-Disposition header or URL
            const contentDisposition = response.headers.get('Content-Disposition');
            let filename = 'download.zip';
            if (contentDisposition) {
                const match = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
                if (match) filename = decodeURIComponent(match[1].replace(/['"]/g, ''));
            }

            console.log('[DownloadFrame] Starting blob download as:', filename);

            // Read the response as blob and trigger download
            const blob = await response.blob();
            console.log('[DownloadFrame] Blob size:', blob.size);

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            console.log('[DownloadFrame] Download triggered');
            window.parent.postMessage({ type: 'DOWNLOAD_COMPLETE' }, '*');

        } catch (error) {
            console.error('[DownloadFrame] Error:', error);
            window.parent.postMessage({ type: 'DOWNLOAD_ERROR', error: error.message }, '*');
        }
    }
});

init();
</script>
</body>
</html>
